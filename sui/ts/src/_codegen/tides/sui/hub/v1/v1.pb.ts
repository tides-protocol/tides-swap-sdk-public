// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               unknown
// source: tides/sui/hub/v1/v1.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import { Observable } from "rxjs";
import { share } from "rxjs/operators";
import { Timestamp } from "../../../../google/protobuf/timestamp.pb";
import { AssetInfo, DeploymentInfo, SharedObject } from "../../common/v1/v1.pb";

/**
 * TODO: Reserve the 0th variant for UNSPECIFIED type,
 * @see https://protobuf.dev/best-practices/dos-donts/#unspecified-enum
 */
export enum NativeOracleType {
  PushOracle = 0,
  PullOracle = 1,
  UNRECOGNIZED = -1,
}

export function nativeOracleTypeFromJSON(object: any): NativeOracleType {
  switch (object) {
    case 0:
    case "PushOracle":
      return NativeOracleType.PushOracle;
    case 1:
    case "PullOracle":
      return NativeOracleType.PullOracle;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NativeOracleType.UNRECOGNIZED;
  }
}

export function nativeOracleTypeToJSON(object: NativeOracleType): string {
  switch (object) {
    case NativeOracleType.PushOracle:
      return "PushOracle";
    case NativeOracleType.PullOracle:
      return "PullOracle";
    case NativeOracleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Rfq {
  /** LE bytes of the unique u128 trade identifier */
  tradeId: Uint8Array;
  /** Optionally, the best quote received from MMs. If it's empty, means no good quote was found. */
  quote?: Quote | undefined;
}

/**
 * Request message for getting deployment information.
 * No parameters needed as this returns static deployment configuration.
 */
export interface DeploymentInfoRequest {
}

/** Response message containing the deployment information for the Tides protocol. */
export interface DeploymentInfoResponse {
  /** The chain ID the hub is deployed on top of. */
  chainId: string;
  /** The deployment information containing essential object IDs. */
  deploymentInfo: DeploymentInfo | undefined;
}

export interface QuoteTradeExactInRequest {
  inputType: string;
  inputAmount: bigint;
  outputType: string;
  minOutputAmount?:
    | bigint
    | undefined;
  /** Timeout for getting quotes from MMs */
  rfqTimeout?:
    | Date
    | undefined;
  /** Quote expiration in ms since the Unix epoch */
  quoteExpiry?: Date | undefined;
}

export interface QuoteTradeExactInResponse {
  rfq: Rfq | undefined;
}

export interface QuoteTradeExactOutRequest {
  inputType: string;
  maxInputAmount?: bigint | undefined;
  outputType: string;
  outputAmount: bigint;
  /** Timeout for getting quotes from MMs */
  rfqTimeout?:
    | Date
    | undefined;
  /** Quote expiration in ms since the Unix epoch */
  quoteExpiry?: Date | undefined;
}

export interface QuoteTradeExactOutResponse {
  rfq: Rfq | undefined;
}

export interface NativeQuotePayload {
  featuredAssets: string[];
  oracleType: NativeOracleType;
  packageId: Uint8Array;
  oracleId: SharedObject | undefined;
}

export interface PythConfig {
  pythStateId: SharedObject | undefined;
  pythPackageId: Uint8Array;
  wormholeStateId: SharedObject | undefined;
  wormholePackageId: Uint8Array;
}

export interface PythPriceUpdate {
  reserveArrayIndex: bigint;
  priceInfoObjectId: SharedObject | undefined;
}

export interface PythPriceUpdatePayload {
  priceUpdates: PythPriceUpdate[];
  updatePriceFee: bigint;
  update: Uint8Array;
  vaa: Uint8Array;
}

export interface SuilendQuotePayload {
  priceUpdatesPayload: PythPriceUpdatePayload | undefined;
  pythConfig: PythConfig | undefined;
  suilendPackageId: Uint8Array;
  suilendLendingMarketId: SharedObject | undefined;
}

export interface Quote {
  inputAmount: bigint;
  outputAmount: bigint;
  outputFloor: bigint;
  rfqAccountId:
    | SharedObject
    | undefined;
  /** LE bytes of the u128 nonce */
  nonce: Uint8Array;
  protectedMarginAccountId: SharedObject | undefined;
  signature: Uint8Array;
  expiryTimestampUnixMs: bigint;
  nativePayload?: NativeQuotePayload | undefined;
  suilendPayload?: SuilendQuotePayload | undefined;
}

export interface ListAssetsRequest {
}

export interface ListAssetsResponse {
  assets: AssetInfo[];
}

export interface StreamRfqWinnersRequest {
}

export interface StreamRfqWinnersResponse {
  /** LE bytes of the unique u128 trade identifier */
  tradeId: Uint8Array;
  /** The account ID of the rfq winner. */
  rfqWinnerAccountId?: Uint8Array | undefined;
}

function createBaseRfq(): Rfq {
  return { tradeId: new Uint8Array(0), quote: undefined };
}

export const Rfq: MessageFns<Rfq> = {
  encode(message: Rfq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tradeId.length !== 0) {
      writer.uint32(10).bytes(message.tradeId);
    }
    if (message.quote !== undefined) {
      Quote.encode(message.quote, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rfq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRfq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tradeId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = Quote.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rfq {
    return {
      tradeId: isSet(object.tradeId) ? bytesFromBase64(object.tradeId) : new Uint8Array(0),
      quote: isSet(object.quote) ? Quote.fromJSON(object.quote) : undefined,
    };
  },

  toJSON(message: Rfq): unknown {
    const obj: any = {};
    if (message.tradeId.length !== 0) {
      obj.tradeId = base64FromBytes(message.tradeId);
    }
    if (message.quote !== undefined) {
      obj.quote = Quote.toJSON(message.quote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Rfq>, I>>(base?: I): Rfq {
    return Rfq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Rfq>, I>>(object: I): Rfq {
    const message = createBaseRfq();
    message.tradeId = object.tradeId ?? new Uint8Array(0);
    message.quote = (object.quote !== undefined && object.quote !== null) ? Quote.fromPartial(object.quote) : undefined;
    return message;
  },
};

function createBaseDeploymentInfoRequest(): DeploymentInfoRequest {
  return {};
}

export const DeploymentInfoRequest: MessageFns<DeploymentInfoRequest> = {
  encode(_: DeploymentInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeploymentInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeploymentInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeploymentInfoRequest {
    return {};
  },

  toJSON(_: DeploymentInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeploymentInfoRequest>, I>>(base?: I): DeploymentInfoRequest {
    return DeploymentInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeploymentInfoRequest>, I>>(_: I): DeploymentInfoRequest {
    const message = createBaseDeploymentInfoRequest();
    return message;
  },
};

function createBaseDeploymentInfoResponse(): DeploymentInfoResponse {
  return { chainId: "", deploymentInfo: undefined };
}

export const DeploymentInfoResponse: MessageFns<DeploymentInfoResponse> = {
  encode(message: DeploymentInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.deploymentInfo !== undefined) {
      DeploymentInfo.encode(message.deploymentInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeploymentInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeploymentInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deploymentInfo = DeploymentInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeploymentInfoResponse {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      deploymentInfo: isSet(object.deploymentInfo) ? DeploymentInfo.fromJSON(object.deploymentInfo) : undefined,
    };
  },

  toJSON(message: DeploymentInfoResponse): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.deploymentInfo !== undefined) {
      obj.deploymentInfo = DeploymentInfo.toJSON(message.deploymentInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeploymentInfoResponse>, I>>(base?: I): DeploymentInfoResponse {
    return DeploymentInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeploymentInfoResponse>, I>>(object: I): DeploymentInfoResponse {
    const message = createBaseDeploymentInfoResponse();
    message.chainId = object.chainId ?? "";
    message.deploymentInfo = (object.deploymentInfo !== undefined && object.deploymentInfo !== null)
      ? DeploymentInfo.fromPartial(object.deploymentInfo)
      : undefined;
    return message;
  },
};

function createBaseQuoteTradeExactInRequest(): QuoteTradeExactInRequest {
  return {
    inputType: "",
    inputAmount: 0n,
    outputType: "",
    minOutputAmount: undefined,
    rfqTimeout: undefined,
    quoteExpiry: undefined,
  };
}

export const QuoteTradeExactInRequest: MessageFns<QuoteTradeExactInRequest> = {
  encode(message: QuoteTradeExactInRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputType !== "") {
      writer.uint32(10).string(message.inputType);
    }
    if (message.inputAmount !== 0n) {
      if (BigInt.asUintN(64, message.inputAmount) !== message.inputAmount) {
        throw new globalThis.Error("value provided for field message.inputAmount of type uint64 too large");
      }
      writer.uint32(16).uint64(message.inputAmount);
    }
    if (message.outputType !== "") {
      writer.uint32(26).string(message.outputType);
    }
    if (message.minOutputAmount !== undefined) {
      if (BigInt.asUintN(64, message.minOutputAmount) !== message.minOutputAmount) {
        throw new globalThis.Error("value provided for field message.minOutputAmount of type uint64 too large");
      }
      writer.uint32(32).uint64(message.minOutputAmount);
    }
    if (message.rfqTimeout !== undefined) {
      Timestamp.encode(toTimestamp(message.rfqTimeout), writer.uint32(42).fork()).join();
    }
    if (message.quoteExpiry !== undefined) {
      Timestamp.encode(toTimestamp(message.quoteExpiry), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuoteTradeExactInRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuoteTradeExactInRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inputAmount = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outputType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.minOutputAmount = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rfqTimeout = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.quoteExpiry = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuoteTradeExactInRequest {
    return {
      inputType: isSet(object.inputType) ? globalThis.String(object.inputType) : "",
      inputAmount: isSet(object.inputAmount) ? BigInt(object.inputAmount) : 0n,
      outputType: isSet(object.outputType) ? globalThis.String(object.outputType) : "",
      minOutputAmount: isSet(object.minOutputAmount) ? BigInt(object.minOutputAmount) : undefined,
      rfqTimeout: isSet(object.rfqTimeout) ? fromJsonTimestamp(object.rfqTimeout) : undefined,
      quoteExpiry: isSet(object.quoteExpiry) ? fromJsonTimestamp(object.quoteExpiry) : undefined,
    };
  },

  toJSON(message: QuoteTradeExactInRequest): unknown {
    const obj: any = {};
    if (message.inputType !== "") {
      obj.inputType = message.inputType;
    }
    if (message.inputAmount !== 0n) {
      obj.inputAmount = message.inputAmount.toString();
    }
    if (message.outputType !== "") {
      obj.outputType = message.outputType;
    }
    if (message.minOutputAmount !== undefined) {
      obj.minOutputAmount = message.minOutputAmount.toString();
    }
    if (message.rfqTimeout !== undefined) {
      obj.rfqTimeout = message.rfqTimeout.toISOString();
    }
    if (message.quoteExpiry !== undefined) {
      obj.quoteExpiry = message.quoteExpiry.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteTradeExactInRequest>, I>>(base?: I): QuoteTradeExactInRequest {
    return QuoteTradeExactInRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteTradeExactInRequest>, I>>(object: I): QuoteTradeExactInRequest {
    const message = createBaseQuoteTradeExactInRequest();
    message.inputType = object.inputType ?? "";
    message.inputAmount = object.inputAmount ?? 0n;
    message.outputType = object.outputType ?? "";
    message.minOutputAmount = object.minOutputAmount ?? undefined;
    message.rfqTimeout = object.rfqTimeout ?? undefined;
    message.quoteExpiry = object.quoteExpiry ?? undefined;
    return message;
  },
};

function createBaseQuoteTradeExactInResponse(): QuoteTradeExactInResponse {
  return { rfq: undefined };
}

export const QuoteTradeExactInResponse: MessageFns<QuoteTradeExactInResponse> = {
  encode(message: QuoteTradeExactInResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rfq !== undefined) {
      Rfq.encode(message.rfq, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuoteTradeExactInResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuoteTradeExactInResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rfq = Rfq.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuoteTradeExactInResponse {
    return { rfq: isSet(object.rfq) ? Rfq.fromJSON(object.rfq) : undefined };
  },

  toJSON(message: QuoteTradeExactInResponse): unknown {
    const obj: any = {};
    if (message.rfq !== undefined) {
      obj.rfq = Rfq.toJSON(message.rfq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteTradeExactInResponse>, I>>(base?: I): QuoteTradeExactInResponse {
    return QuoteTradeExactInResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteTradeExactInResponse>, I>>(object: I): QuoteTradeExactInResponse {
    const message = createBaseQuoteTradeExactInResponse();
    message.rfq = (object.rfq !== undefined && object.rfq !== null) ? Rfq.fromPartial(object.rfq) : undefined;
    return message;
  },
};

function createBaseQuoteTradeExactOutRequest(): QuoteTradeExactOutRequest {
  return {
    inputType: "",
    maxInputAmount: undefined,
    outputType: "",
    outputAmount: 0n,
    rfqTimeout: undefined,
    quoteExpiry: undefined,
  };
}

export const QuoteTradeExactOutRequest: MessageFns<QuoteTradeExactOutRequest> = {
  encode(message: QuoteTradeExactOutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputType !== "") {
      writer.uint32(10).string(message.inputType);
    }
    if (message.maxInputAmount !== undefined) {
      if (BigInt.asUintN(64, message.maxInputAmount) !== message.maxInputAmount) {
        throw new globalThis.Error("value provided for field message.maxInputAmount of type uint64 too large");
      }
      writer.uint32(16).uint64(message.maxInputAmount);
    }
    if (message.outputType !== "") {
      writer.uint32(26).string(message.outputType);
    }
    if (message.outputAmount !== 0n) {
      if (BigInt.asUintN(64, message.outputAmount) !== message.outputAmount) {
        throw new globalThis.Error("value provided for field message.outputAmount of type uint64 too large");
      }
      writer.uint32(32).uint64(message.outputAmount);
    }
    if (message.rfqTimeout !== undefined) {
      Timestamp.encode(toTimestamp(message.rfqTimeout), writer.uint32(42).fork()).join();
    }
    if (message.quoteExpiry !== undefined) {
      Timestamp.encode(toTimestamp(message.quoteExpiry), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuoteTradeExactOutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuoteTradeExactOutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxInputAmount = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outputType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.outputAmount = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rfqTimeout = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.quoteExpiry = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuoteTradeExactOutRequest {
    return {
      inputType: isSet(object.inputType) ? globalThis.String(object.inputType) : "",
      maxInputAmount: isSet(object.maxInputAmount) ? BigInt(object.maxInputAmount) : undefined,
      outputType: isSet(object.outputType) ? globalThis.String(object.outputType) : "",
      outputAmount: isSet(object.outputAmount) ? BigInt(object.outputAmount) : 0n,
      rfqTimeout: isSet(object.rfqTimeout) ? fromJsonTimestamp(object.rfqTimeout) : undefined,
      quoteExpiry: isSet(object.quoteExpiry) ? fromJsonTimestamp(object.quoteExpiry) : undefined,
    };
  },

  toJSON(message: QuoteTradeExactOutRequest): unknown {
    const obj: any = {};
    if (message.inputType !== "") {
      obj.inputType = message.inputType;
    }
    if (message.maxInputAmount !== undefined) {
      obj.maxInputAmount = message.maxInputAmount.toString();
    }
    if (message.outputType !== "") {
      obj.outputType = message.outputType;
    }
    if (message.outputAmount !== 0n) {
      obj.outputAmount = message.outputAmount.toString();
    }
    if (message.rfqTimeout !== undefined) {
      obj.rfqTimeout = message.rfqTimeout.toISOString();
    }
    if (message.quoteExpiry !== undefined) {
      obj.quoteExpiry = message.quoteExpiry.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteTradeExactOutRequest>, I>>(base?: I): QuoteTradeExactOutRequest {
    return QuoteTradeExactOutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteTradeExactOutRequest>, I>>(object: I): QuoteTradeExactOutRequest {
    const message = createBaseQuoteTradeExactOutRequest();
    message.inputType = object.inputType ?? "";
    message.maxInputAmount = object.maxInputAmount ?? undefined;
    message.outputType = object.outputType ?? "";
    message.outputAmount = object.outputAmount ?? 0n;
    message.rfqTimeout = object.rfqTimeout ?? undefined;
    message.quoteExpiry = object.quoteExpiry ?? undefined;
    return message;
  },
};

function createBaseQuoteTradeExactOutResponse(): QuoteTradeExactOutResponse {
  return { rfq: undefined };
}

export const QuoteTradeExactOutResponse: MessageFns<QuoteTradeExactOutResponse> = {
  encode(message: QuoteTradeExactOutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rfq !== undefined) {
      Rfq.encode(message.rfq, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuoteTradeExactOutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuoteTradeExactOutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rfq = Rfq.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuoteTradeExactOutResponse {
    return { rfq: isSet(object.rfq) ? Rfq.fromJSON(object.rfq) : undefined };
  },

  toJSON(message: QuoteTradeExactOutResponse): unknown {
    const obj: any = {};
    if (message.rfq !== undefined) {
      obj.rfq = Rfq.toJSON(message.rfq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteTradeExactOutResponse>, I>>(base?: I): QuoteTradeExactOutResponse {
    return QuoteTradeExactOutResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteTradeExactOutResponse>, I>>(object: I): QuoteTradeExactOutResponse {
    const message = createBaseQuoteTradeExactOutResponse();
    message.rfq = (object.rfq !== undefined && object.rfq !== null) ? Rfq.fromPartial(object.rfq) : undefined;
    return message;
  },
};

function createBaseNativeQuotePayload(): NativeQuotePayload {
  return { featuredAssets: [], oracleType: 0, packageId: new Uint8Array(0), oracleId: undefined };
}

export const NativeQuotePayload: MessageFns<NativeQuotePayload> = {
  encode(message: NativeQuotePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.featuredAssets) {
      writer.uint32(10).string(v!);
    }
    if (message.oracleType !== 0) {
      writer.uint32(16).int32(message.oracleType);
    }
    if (message.packageId.length !== 0) {
      writer.uint32(26).bytes(message.packageId);
    }
    if (message.oracleId !== undefined) {
      SharedObject.encode(message.oracleId, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NativeQuotePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNativeQuotePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.featuredAssets.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.oracleType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.packageId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.oracleId = SharedObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NativeQuotePayload {
    return {
      featuredAssets: globalThis.Array.isArray(object?.featuredAssets)
        ? object.featuredAssets.map((e: any) => globalThis.String(e))
        : [],
      oracleType: isSet(object.oracleType) ? nativeOracleTypeFromJSON(object.oracleType) : 0,
      packageId: isSet(object.packageId) ? bytesFromBase64(object.packageId) : new Uint8Array(0),
      oracleId: isSet(object.oracleId) ? SharedObject.fromJSON(object.oracleId) : undefined,
    };
  },

  toJSON(message: NativeQuotePayload): unknown {
    const obj: any = {};
    if (message.featuredAssets?.length) {
      obj.featuredAssets = message.featuredAssets;
    }
    if (message.oracleType !== 0) {
      obj.oracleType = nativeOracleTypeToJSON(message.oracleType);
    }
    if (message.packageId.length !== 0) {
      obj.packageId = base64FromBytes(message.packageId);
    }
    if (message.oracleId !== undefined) {
      obj.oracleId = SharedObject.toJSON(message.oracleId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NativeQuotePayload>, I>>(base?: I): NativeQuotePayload {
    return NativeQuotePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NativeQuotePayload>, I>>(object: I): NativeQuotePayload {
    const message = createBaseNativeQuotePayload();
    message.featuredAssets = object.featuredAssets?.map((e) => e) || [];
    message.oracleType = object.oracleType ?? 0;
    message.packageId = object.packageId ?? new Uint8Array(0);
    message.oracleId = (object.oracleId !== undefined && object.oracleId !== null)
      ? SharedObject.fromPartial(object.oracleId)
      : undefined;
    return message;
  },
};

function createBasePythConfig(): PythConfig {
  return {
    pythStateId: undefined,
    pythPackageId: new Uint8Array(0),
    wormholeStateId: undefined,
    wormholePackageId: new Uint8Array(0),
  };
}

export const PythConfig: MessageFns<PythConfig> = {
  encode(message: PythConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pythStateId !== undefined) {
      SharedObject.encode(message.pythStateId, writer.uint32(10).fork()).join();
    }
    if (message.pythPackageId.length !== 0) {
      writer.uint32(18).bytes(message.pythPackageId);
    }
    if (message.wormholeStateId !== undefined) {
      SharedObject.encode(message.wormholeStateId, writer.uint32(26).fork()).join();
    }
    if (message.wormholePackageId.length !== 0) {
      writer.uint32(34).bytes(message.wormholePackageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PythConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePythConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pythStateId = SharedObject.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pythPackageId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.wormholeStateId = SharedObject.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.wormholePackageId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PythConfig {
    return {
      pythStateId: isSet(object.pythStateId) ? SharedObject.fromJSON(object.pythStateId) : undefined,
      pythPackageId: isSet(object.pythPackageId) ? bytesFromBase64(object.pythPackageId) : new Uint8Array(0),
      wormholeStateId: isSet(object.wormholeStateId) ? SharedObject.fromJSON(object.wormholeStateId) : undefined,
      wormholePackageId: isSet(object.wormholePackageId)
        ? bytesFromBase64(object.wormholePackageId)
        : new Uint8Array(0),
    };
  },

  toJSON(message: PythConfig): unknown {
    const obj: any = {};
    if (message.pythStateId !== undefined) {
      obj.pythStateId = SharedObject.toJSON(message.pythStateId);
    }
    if (message.pythPackageId.length !== 0) {
      obj.pythPackageId = base64FromBytes(message.pythPackageId);
    }
    if (message.wormholeStateId !== undefined) {
      obj.wormholeStateId = SharedObject.toJSON(message.wormholeStateId);
    }
    if (message.wormholePackageId.length !== 0) {
      obj.wormholePackageId = base64FromBytes(message.wormholePackageId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PythConfig>, I>>(base?: I): PythConfig {
    return PythConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PythConfig>, I>>(object: I): PythConfig {
    const message = createBasePythConfig();
    message.pythStateId = (object.pythStateId !== undefined && object.pythStateId !== null)
      ? SharedObject.fromPartial(object.pythStateId)
      : undefined;
    message.pythPackageId = object.pythPackageId ?? new Uint8Array(0);
    message.wormholeStateId = (object.wormholeStateId !== undefined && object.wormholeStateId !== null)
      ? SharedObject.fromPartial(object.wormholeStateId)
      : undefined;
    message.wormholePackageId = object.wormholePackageId ?? new Uint8Array(0);
    return message;
  },
};

function createBasePythPriceUpdate(): PythPriceUpdate {
  return { reserveArrayIndex: 0n, priceInfoObjectId: undefined };
}

export const PythPriceUpdate: MessageFns<PythPriceUpdate> = {
  encode(message: PythPriceUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reserveArrayIndex !== 0n) {
      if (BigInt.asUintN(64, message.reserveArrayIndex) !== message.reserveArrayIndex) {
        throw new globalThis.Error("value provided for field message.reserveArrayIndex of type uint64 too large");
      }
      writer.uint32(8).uint64(message.reserveArrayIndex);
    }
    if (message.priceInfoObjectId !== undefined) {
      SharedObject.encode(message.priceInfoObjectId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PythPriceUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePythPriceUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reserveArrayIndex = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.priceInfoObjectId = SharedObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PythPriceUpdate {
    return {
      reserveArrayIndex: isSet(object.reserveArrayIndex) ? BigInt(object.reserveArrayIndex) : 0n,
      priceInfoObjectId: isSet(object.priceInfoObjectId) ? SharedObject.fromJSON(object.priceInfoObjectId) : undefined,
    };
  },

  toJSON(message: PythPriceUpdate): unknown {
    const obj: any = {};
    if (message.reserveArrayIndex !== 0n) {
      obj.reserveArrayIndex = message.reserveArrayIndex.toString();
    }
    if (message.priceInfoObjectId !== undefined) {
      obj.priceInfoObjectId = SharedObject.toJSON(message.priceInfoObjectId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PythPriceUpdate>, I>>(base?: I): PythPriceUpdate {
    return PythPriceUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PythPriceUpdate>, I>>(object: I): PythPriceUpdate {
    const message = createBasePythPriceUpdate();
    message.reserveArrayIndex = object.reserveArrayIndex ?? 0n;
    message.priceInfoObjectId = (object.priceInfoObjectId !== undefined && object.priceInfoObjectId !== null)
      ? SharedObject.fromPartial(object.priceInfoObjectId)
      : undefined;
    return message;
  },
};

function createBasePythPriceUpdatePayload(): PythPriceUpdatePayload {
  return { priceUpdates: [], updatePriceFee: 0n, update: new Uint8Array(0), vaa: new Uint8Array(0) };
}

export const PythPriceUpdatePayload: MessageFns<PythPriceUpdatePayload> = {
  encode(message: PythPriceUpdatePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.priceUpdates) {
      PythPriceUpdate.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.updatePriceFee !== 0n) {
      if (BigInt.asUintN(64, message.updatePriceFee) !== message.updatePriceFee) {
        throw new globalThis.Error("value provided for field message.updatePriceFee of type uint64 too large");
      }
      writer.uint32(16).uint64(message.updatePriceFee);
    }
    if (message.update.length !== 0) {
      writer.uint32(26).bytes(message.update);
    }
    if (message.vaa.length !== 0) {
      writer.uint32(34).bytes(message.vaa);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PythPriceUpdatePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePythPriceUpdatePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.priceUpdates.push(PythPriceUpdate.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.updatePriceFee = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.update = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.vaa = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PythPriceUpdatePayload {
    return {
      priceUpdates: globalThis.Array.isArray(object?.priceUpdates)
        ? object.priceUpdates.map((e: any) => PythPriceUpdate.fromJSON(e))
        : [],
      updatePriceFee: isSet(object.updatePriceFee) ? BigInt(object.updatePriceFee) : 0n,
      update: isSet(object.update) ? bytesFromBase64(object.update) : new Uint8Array(0),
      vaa: isSet(object.vaa) ? bytesFromBase64(object.vaa) : new Uint8Array(0),
    };
  },

  toJSON(message: PythPriceUpdatePayload): unknown {
    const obj: any = {};
    if (message.priceUpdates?.length) {
      obj.priceUpdates = message.priceUpdates.map((e) => PythPriceUpdate.toJSON(e));
    }
    if (message.updatePriceFee !== 0n) {
      obj.updatePriceFee = message.updatePriceFee.toString();
    }
    if (message.update.length !== 0) {
      obj.update = base64FromBytes(message.update);
    }
    if (message.vaa.length !== 0) {
      obj.vaa = base64FromBytes(message.vaa);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PythPriceUpdatePayload>, I>>(base?: I): PythPriceUpdatePayload {
    return PythPriceUpdatePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PythPriceUpdatePayload>, I>>(object: I): PythPriceUpdatePayload {
    const message = createBasePythPriceUpdatePayload();
    message.priceUpdates = object.priceUpdates?.map((e) => PythPriceUpdate.fromPartial(e)) || [];
    message.updatePriceFee = object.updatePriceFee ?? 0n;
    message.update = object.update ?? new Uint8Array(0);
    message.vaa = object.vaa ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSuilendQuotePayload(): SuilendQuotePayload {
  return {
    priceUpdatesPayload: undefined,
    pythConfig: undefined,
    suilendPackageId: new Uint8Array(0),
    suilendLendingMarketId: undefined,
  };
}

export const SuilendQuotePayload: MessageFns<SuilendQuotePayload> = {
  encode(message: SuilendQuotePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.priceUpdatesPayload !== undefined) {
      PythPriceUpdatePayload.encode(message.priceUpdatesPayload, writer.uint32(10).fork()).join();
    }
    if (message.pythConfig !== undefined) {
      PythConfig.encode(message.pythConfig, writer.uint32(18).fork()).join();
    }
    if (message.suilendPackageId.length !== 0) {
      writer.uint32(26).bytes(message.suilendPackageId);
    }
    if (message.suilendLendingMarketId !== undefined) {
      SharedObject.encode(message.suilendLendingMarketId, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuilendQuotePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuilendQuotePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.priceUpdatesPayload = PythPriceUpdatePayload.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pythConfig = PythConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.suilendPackageId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.suilendLendingMarketId = SharedObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuilendQuotePayload {
    return {
      priceUpdatesPayload: isSet(object.priceUpdatesPayload)
        ? PythPriceUpdatePayload.fromJSON(object.priceUpdatesPayload)
        : undefined,
      pythConfig: isSet(object.pythConfig) ? PythConfig.fromJSON(object.pythConfig) : undefined,
      suilendPackageId: isSet(object.suilendPackageId) ? bytesFromBase64(object.suilendPackageId) : new Uint8Array(0),
      suilendLendingMarketId: isSet(object.suilendLendingMarketId)
        ? SharedObject.fromJSON(object.suilendLendingMarketId)
        : undefined,
    };
  },

  toJSON(message: SuilendQuotePayload): unknown {
    const obj: any = {};
    if (message.priceUpdatesPayload !== undefined) {
      obj.priceUpdatesPayload = PythPriceUpdatePayload.toJSON(message.priceUpdatesPayload);
    }
    if (message.pythConfig !== undefined) {
      obj.pythConfig = PythConfig.toJSON(message.pythConfig);
    }
    if (message.suilendPackageId.length !== 0) {
      obj.suilendPackageId = base64FromBytes(message.suilendPackageId);
    }
    if (message.suilendLendingMarketId !== undefined) {
      obj.suilendLendingMarketId = SharedObject.toJSON(message.suilendLendingMarketId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SuilendQuotePayload>, I>>(base?: I): SuilendQuotePayload {
    return SuilendQuotePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SuilendQuotePayload>, I>>(object: I): SuilendQuotePayload {
    const message = createBaseSuilendQuotePayload();
    message.priceUpdatesPayload = (object.priceUpdatesPayload !== undefined && object.priceUpdatesPayload !== null)
      ? PythPriceUpdatePayload.fromPartial(object.priceUpdatesPayload)
      : undefined;
    message.pythConfig = (object.pythConfig !== undefined && object.pythConfig !== null)
      ? PythConfig.fromPartial(object.pythConfig)
      : undefined;
    message.suilendPackageId = object.suilendPackageId ?? new Uint8Array(0);
    message.suilendLendingMarketId =
      (object.suilendLendingMarketId !== undefined && object.suilendLendingMarketId !== null)
        ? SharedObject.fromPartial(object.suilendLendingMarketId)
        : undefined;
    return message;
  },
};

function createBaseQuote(): Quote {
  return {
    inputAmount: 0n,
    outputAmount: 0n,
    outputFloor: 0n,
    rfqAccountId: undefined,
    nonce: new Uint8Array(0),
    protectedMarginAccountId: undefined,
    signature: new Uint8Array(0),
    expiryTimestampUnixMs: 0n,
    nativePayload: undefined,
    suilendPayload: undefined,
  };
}

export const Quote: MessageFns<Quote> = {
  encode(message: Quote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputAmount !== 0n) {
      if (BigInt.asUintN(64, message.inputAmount) !== message.inputAmount) {
        throw new globalThis.Error("value provided for field message.inputAmount of type uint64 too large");
      }
      writer.uint32(8).uint64(message.inputAmount);
    }
    if (message.outputAmount !== 0n) {
      if (BigInt.asUintN(64, message.outputAmount) !== message.outputAmount) {
        throw new globalThis.Error("value provided for field message.outputAmount of type uint64 too large");
      }
      writer.uint32(16).uint64(message.outputAmount);
    }
    if (message.outputFloor !== 0n) {
      if (BigInt.asUintN(64, message.outputFloor) !== message.outputFloor) {
        throw new globalThis.Error("value provided for field message.outputFloor of type uint64 too large");
      }
      writer.uint32(24).uint64(message.outputFloor);
    }
    if (message.rfqAccountId !== undefined) {
      SharedObject.encode(message.rfqAccountId, writer.uint32(34).fork()).join();
    }
    if (message.nonce.length !== 0) {
      writer.uint32(42).bytes(message.nonce);
    }
    if (message.protectedMarginAccountId !== undefined) {
      SharedObject.encode(message.protectedMarginAccountId, writer.uint32(50).fork()).join();
    }
    if (message.signature.length !== 0) {
      writer.uint32(58).bytes(message.signature);
    }
    if (message.expiryTimestampUnixMs !== 0n) {
      if (BigInt.asUintN(64, message.expiryTimestampUnixMs) !== message.expiryTimestampUnixMs) {
        throw new globalThis.Error("value provided for field message.expiryTimestampUnixMs of type uint64 too large");
      }
      writer.uint32(64).uint64(message.expiryTimestampUnixMs);
    }
    if (message.nativePayload !== undefined) {
      NativeQuotePayload.encode(message.nativePayload, writer.uint32(74).fork()).join();
    }
    if (message.suilendPayload !== undefined) {
      SuilendQuotePayload.encode(message.suilendPayload, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Quote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inputAmount = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.outputAmount = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.outputFloor = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rfqAccountId = SharedObject.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.protectedMarginAccountId = SharedObject.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.expiryTimestampUnixMs = reader.uint64() as bigint;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.nativePayload = NativeQuotePayload.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.suilendPayload = SuilendQuotePayload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Quote {
    return {
      inputAmount: isSet(object.inputAmount) ? BigInt(object.inputAmount) : 0n,
      outputAmount: isSet(object.outputAmount) ? BigInt(object.outputAmount) : 0n,
      outputFloor: isSet(object.outputFloor) ? BigInt(object.outputFloor) : 0n,
      rfqAccountId: isSet(object.rfqAccountId) ? SharedObject.fromJSON(object.rfqAccountId) : undefined,
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      protectedMarginAccountId: isSet(object.protectedMarginAccountId)
        ? SharedObject.fromJSON(object.protectedMarginAccountId)
        : undefined,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      expiryTimestampUnixMs: isSet(object.expiryTimestampUnixMs) ? BigInt(object.expiryTimestampUnixMs) : 0n,
      nativePayload: isSet(object.nativePayload) ? NativeQuotePayload.fromJSON(object.nativePayload) : undefined,
      suilendPayload: isSet(object.suilendPayload) ? SuilendQuotePayload.fromJSON(object.suilendPayload) : undefined,
    };
  },

  toJSON(message: Quote): unknown {
    const obj: any = {};
    if (message.inputAmount !== 0n) {
      obj.inputAmount = message.inputAmount.toString();
    }
    if (message.outputAmount !== 0n) {
      obj.outputAmount = message.outputAmount.toString();
    }
    if (message.outputFloor !== 0n) {
      obj.outputFloor = message.outputFloor.toString();
    }
    if (message.rfqAccountId !== undefined) {
      obj.rfqAccountId = SharedObject.toJSON(message.rfqAccountId);
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.protectedMarginAccountId !== undefined) {
      obj.protectedMarginAccountId = SharedObject.toJSON(message.protectedMarginAccountId);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.expiryTimestampUnixMs !== 0n) {
      obj.expiryTimestampUnixMs = message.expiryTimestampUnixMs.toString();
    }
    if (message.nativePayload !== undefined) {
      obj.nativePayload = NativeQuotePayload.toJSON(message.nativePayload);
    }
    if (message.suilendPayload !== undefined) {
      obj.suilendPayload = SuilendQuotePayload.toJSON(message.suilendPayload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Quote>, I>>(base?: I): Quote {
    return Quote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Quote>, I>>(object: I): Quote {
    const message = createBaseQuote();
    message.inputAmount = object.inputAmount ?? 0n;
    message.outputAmount = object.outputAmount ?? 0n;
    message.outputFloor = object.outputFloor ?? 0n;
    message.rfqAccountId = (object.rfqAccountId !== undefined && object.rfqAccountId !== null)
      ? SharedObject.fromPartial(object.rfqAccountId)
      : undefined;
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.protectedMarginAccountId =
      (object.protectedMarginAccountId !== undefined && object.protectedMarginAccountId !== null)
        ? SharedObject.fromPartial(object.protectedMarginAccountId)
        : undefined;
    message.signature = object.signature ?? new Uint8Array(0);
    message.expiryTimestampUnixMs = object.expiryTimestampUnixMs ?? 0n;
    message.nativePayload = (object.nativePayload !== undefined && object.nativePayload !== null)
      ? NativeQuotePayload.fromPartial(object.nativePayload)
      : undefined;
    message.suilendPayload = (object.suilendPayload !== undefined && object.suilendPayload !== null)
      ? SuilendQuotePayload.fromPartial(object.suilendPayload)
      : undefined;
    return message;
  },
};

function createBaseListAssetsRequest(): ListAssetsRequest {
  return {};
}

export const ListAssetsRequest: MessageFns<ListAssetsRequest> = {
  encode(_: ListAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListAssetsRequest {
    return {};
  },

  toJSON(_: ListAssetsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAssetsRequest>, I>>(base?: I): ListAssetsRequest {
    return ListAssetsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAssetsRequest>, I>>(_: I): ListAssetsRequest {
    const message = createBaseListAssetsRequest();
    return message;
  },
};

function createBaseListAssetsResponse(): ListAssetsResponse {
  return { assets: [] };
}

export const ListAssetsResponse: MessageFns<ListAssetsResponse> = {
  encode(message: ListAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assets) {
      AssetInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assets.push(AssetInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsResponse {
    return {
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => AssetInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListAssetsResponse): unknown {
    const obj: any = {};
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => AssetInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAssetsResponse>, I>>(base?: I): ListAssetsResponse {
    return ListAssetsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAssetsResponse>, I>>(object: I): ListAssetsResponse {
    const message = createBaseListAssetsResponse();
    message.assets = object.assets?.map((e) => AssetInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamRfqWinnersRequest(): StreamRfqWinnersRequest {
  return {};
}

export const StreamRfqWinnersRequest: MessageFns<StreamRfqWinnersRequest> = {
  encode(_: StreamRfqWinnersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamRfqWinnersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamRfqWinnersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StreamRfqWinnersRequest {
    return {};
  },

  toJSON(_: StreamRfqWinnersRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamRfqWinnersRequest>, I>>(base?: I): StreamRfqWinnersRequest {
    return StreamRfqWinnersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamRfqWinnersRequest>, I>>(_: I): StreamRfqWinnersRequest {
    const message = createBaseStreamRfqWinnersRequest();
    return message;
  },
};

function createBaseStreamRfqWinnersResponse(): StreamRfqWinnersResponse {
  return { tradeId: new Uint8Array(0), rfqWinnerAccountId: undefined };
}

export const StreamRfqWinnersResponse: MessageFns<StreamRfqWinnersResponse> = {
  encode(message: StreamRfqWinnersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tradeId.length !== 0) {
      writer.uint32(10).bytes(message.tradeId);
    }
    if (message.rfqWinnerAccountId !== undefined) {
      writer.uint32(18).bytes(message.rfqWinnerAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamRfqWinnersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamRfqWinnersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tradeId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rfqWinnerAccountId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamRfqWinnersResponse {
    return {
      tradeId: isSet(object.tradeId) ? bytesFromBase64(object.tradeId) : new Uint8Array(0),
      rfqWinnerAccountId: isSet(object.rfqWinnerAccountId) ? bytesFromBase64(object.rfqWinnerAccountId) : undefined,
    };
  },

  toJSON(message: StreamRfqWinnersResponse): unknown {
    const obj: any = {};
    if (message.tradeId.length !== 0) {
      obj.tradeId = base64FromBytes(message.tradeId);
    }
    if (message.rfqWinnerAccountId !== undefined) {
      obj.rfqWinnerAccountId = base64FromBytes(message.rfqWinnerAccountId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamRfqWinnersResponse>, I>>(base?: I): StreamRfqWinnersResponse {
    return StreamRfqWinnersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamRfqWinnersResponse>, I>>(object: I): StreamRfqWinnersResponse {
    const message = createBaseStreamRfqWinnersResponse();
    message.tradeId = object.tradeId ?? new Uint8Array(0);
    message.rfqWinnerAccountId = object.rfqWinnerAccountId ?? undefined;
    return message;
  },
};

export interface HubService {
  /** Returns deployment information containing essential object IDs for the Tides protocol deployment. */
  deploymentInfo(
    request: DeepPartial<DeploymentInfoRequest>,
    metadata?: grpc.Metadata,
  ): Promise<DeploymentInfoResponse>;
  /** Returns Quote for the specified input and min output. */
  quoteTradeExactIn(
    request: DeepPartial<QuoteTradeExactInRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuoteTradeExactInResponse>;
  /** Returns Quote for the specified output and max input. */
  quoteTradeExactOut(
    request: DeepPartial<QuoteTradeExactOutRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuoteTradeExactOutResponse>;
  /** Returns list of the supported assets. */
  listAssets(request: DeepPartial<ListAssetsRequest>, metadata?: grpc.Metadata): Promise<ListAssetsResponse>;
  /**
   * NOTE: Ultimately what needs to be relied on for a trade execution is what happens on chain,
   * although you are guaranteed that, if a notification of the winner is received then that's what
   * can happen on chain.
   * Not receiving a specific trade ID winner can still make it land on chain as the hub does not treat
   * notification failures as important ones.
   */
  streamRfqWinners(
    request: DeepPartial<StreamRfqWinnersRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamRfqWinnersResponse>;
}

export class HubServiceClientImpl implements HubService {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.deploymentInfo = this.deploymentInfo.bind(this);
    this.quoteTradeExactIn = this.quoteTradeExactIn.bind(this);
    this.quoteTradeExactOut = this.quoteTradeExactOut.bind(this);
    this.listAssets = this.listAssets.bind(this);
    this.streamRfqWinners = this.streamRfqWinners.bind(this);
  }

  deploymentInfo(
    request: DeepPartial<DeploymentInfoRequest>,
    metadata?: grpc.Metadata,
  ): Promise<DeploymentInfoResponse> {
    return this.rpc.unary(HubServiceDeploymentInfoDesc, DeploymentInfoRequest.fromPartial(request), metadata);
  }

  quoteTradeExactIn(
    request: DeepPartial<QuoteTradeExactInRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuoteTradeExactInResponse> {
    return this.rpc.unary(HubServiceQuoteTradeExactInDesc, QuoteTradeExactInRequest.fromPartial(request), metadata);
  }

  quoteTradeExactOut(
    request: DeepPartial<QuoteTradeExactOutRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuoteTradeExactOutResponse> {
    return this.rpc.unary(HubServiceQuoteTradeExactOutDesc, QuoteTradeExactOutRequest.fromPartial(request), metadata);
  }

  listAssets(request: DeepPartial<ListAssetsRequest>, metadata?: grpc.Metadata): Promise<ListAssetsResponse> {
    return this.rpc.unary(HubServiceListAssetsDesc, ListAssetsRequest.fromPartial(request), metadata);
  }

  streamRfqWinners(
    request: DeepPartial<StreamRfqWinnersRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamRfqWinnersResponse> {
    return this.rpc.invoke(HubServiceStreamRfqWinnersDesc, StreamRfqWinnersRequest.fromPartial(request), metadata);
  }
}

export const HubServiceDesc = { serviceName: "tides.sui.hub.v1.HubService" };

export const HubServiceDeploymentInfoDesc: UnaryMethodDefinitionish = {
  methodName: "DeploymentInfo",
  service: HubServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeploymentInfoRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeploymentInfoResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const HubServiceQuoteTradeExactInDesc: UnaryMethodDefinitionish = {
  methodName: "QuoteTradeExactIn",
  service: HubServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuoteTradeExactInRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuoteTradeExactInResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const HubServiceQuoteTradeExactOutDesc: UnaryMethodDefinitionish = {
  methodName: "QuoteTradeExactOut",
  service: HubServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuoteTradeExactOutRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuoteTradeExactOutResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const HubServiceListAssetsDesc: UnaryMethodDefinitionish = {
  methodName: "ListAssets",
  service: HubServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListAssetsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListAssetsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const HubServiceStreamRfqWinnersDesc: UnaryMethodDefinitionish = {
  methodName: "StreamRfqWinners",
  service: HubServiceDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamRfqWinnersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamRfqWinnersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;
    streamingTransport?: grpc.TransportFactory;
    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;
      streamingTransport?: grpc.TransportFactory;
      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }

  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any> {
    const upStreamCodes = this.options.upStreamRetryCodes ?? [];
    const DEFAULT_TIMEOUT_TIME: number = 3_000;
    const request = { ..._request, ...methodDesc.requestType };
    const transport = this.options.streamingTransport ?? this.options.transport;
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Observable((observer) => {
      const upStream = () => {
        const client = grpc.invoke(methodDesc, {
          host: this.host,
          request,
          ...(transport !== undefined ? { transport } : {}),
          metadata: maybeCombinedMetadata ?? {},
          debug: this.options.debug ?? false,
          onMessage: (next) => observer.next(next),
          onEnd: (code: grpc.Code, message: string, trailers: grpc.Metadata) => {
            if (code === 0) {
              observer.complete();
            } else if (upStreamCodes.includes(code)) {
              setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
            } else {
              const err = new Error(message) as any;
              err.code = code;
              err.metadata = trailers;
              observer.error(err);
            }
          },
        });
        observer.add(() => client.close());
      };
      upStream();
    }).pipe(share());
  }
}

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = BigInt(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds.toString()) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
